{"version":3,"sources":["App.js","index.js"],"names":["App","useState","currentAccount","setCurrentAccount","allWaves","setAllWaves","message","setMessage","contractAddress","contractABI","abi","checkIfWalletIsConnected","a","window","ethereum","console","log","request","method","accounts","length","account","getAllWaves","connectWallet","alert","provider","ethers","providers","Web3Provider","signer","getSigner","wavePortalContract","Contract","waves","wavesCleaned","map","wave","address","waver","timestamp","Date","useEffect","onNewWave","from","prevState","on","off","getTotalWaves","count","toNumber","waveTxn","hash","wait","className","name","value","onChange","e","target","onClick","index","key","style","backgroundColor","marginTop","padding","toString","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1290cae8.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\r\nimport { ethers } from \"ethers\";\r\nimport abi from \"./utils/WavePortal.json\";\r\nimport \"./App.css\";\r\n\r\nconst App = () => {\r\n  const [currentAccount, setCurrentAccount] = useState(\"\");\r\n /*\r\n   * All state property to store all waves\r\n   */\r\n const [allWaves, setAllWaves] = useState([]);\r\n\r\n\r\n const [message, setMessage] = useState(\"\")\r\n    /**\r\n   * Create a variable here that holds the contract address after you deploy!\r\n   */\r\n     const contractAddress = \"0xe515Eb4036515dBace12443D23b66237e2ED8e2C\";\r\n       /**\r\n   * Create a variable here that references the abi content!\r\n   */\r\n  const contractABI = abi.abi;\r\n\r\n  const checkIfWalletIsConnected = async () => {\r\n    try {\r\n      const { ethereum } = window;\r\n\r\n      if (!ethereum) {\r\n        console.log(\"Make sure you have metamask!\");\r\n        return;\r\n      } else {\r\n        console.log(\"We have the ethereum object\", ethereum);\r\n        \r\n      }\r\n\r\n      const accounts = await ethereum.request({ method: \"eth_accounts\" });\r\n\r\n      if (accounts.length !== 0) {\r\n        const account = accounts[0];\r\n        console.log(\"Found an authorized account:\", account);\r\n        setCurrentAccount(account);\r\n        getAllWaves();\r\n      } else {\r\n        console.log(\"No authorized account found\")\r\n      }\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Implement your connectWallet method here\r\n  */\r\n  const connectWallet = async () => {\r\n    try {\r\n      const { ethereum } = window;\r\n\r\n      if (!ethereum) {\r\n        alert(\"Get MetaMask!\");\r\n        return;\r\n      }\r\n\r\n      const accounts = await ethereum.request({ method: \"eth_requestAccounts\" });\r\n\r\n      console.log(\"Connected\", accounts[0]);\r\n      setCurrentAccount(accounts[0]);\r\n    } catch (error) {\r\n      console.log(error)\r\n    }\r\n  }\r\n /*\r\n   * Create a method that gets all waves from your contract\r\n   */\r\n const getAllWaves = async () => {\r\n  const { ethereum } = window;\r\n\r\n  try {\r\n    if (ethereum) {\r\n      const provider = new ethers.providers.Web3Provider(ethereum);\r\n      const signer = provider.getSigner();\r\n      const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\r\n      const waves = await wavePortalContract.getAllWaves();\r\n      console.log(waves)\r\n      const wavesCleaned = waves.map(wave => {\r\n        return {\r\n          address: wave.waver,\r\n          timestamp: new Date(wave.timestamp * 1000),\r\n          message: wave.message,\r\n        };\r\n      });\r\n\r\n      setAllWaves(wavesCleaned);\r\n    } else {\r\n      console.log(\"Ethereum object doesn't exist!\");\r\n    }\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n\r\n \r\n};\r\n\r\n/**\r\n * Listen in for emitter events!\r\n */\r\nuseEffect(() => {\r\n  let wavePortalContract;\r\n\r\n  const onNewWave = (from, timestamp, message) => {\r\n    console.log(\"NewWave\", from, timestamp, message);\r\n    setAllWaves(prevState => [\r\n      ...prevState,\r\n      {\r\n        address: from,\r\n        timestamp: new Date(timestamp * 1000),\r\n        message: message,\r\n      },\r\n    ]);\r\n  };\r\n\r\n  if (window.ethereum) {\r\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\r\n    const signer = provider.getSigner();\r\n\r\n    wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\r\n    wavePortalContract.on(\"NewWave\", onNewWave);\r\n  }\r\n\r\n  return () => {\r\n    if (wavePortalContract) {\r\n      wavePortalContract.off(\"NewWave\", onNewWave);\r\n    }\r\n  };\r\n}, []);\r\n\r\n  const wave = async () => {\r\n    try {\r\n      const { ethereum } = window;\r\n\r\n      if (ethereum) {\r\n        const provider = new ethers.providers.Web3Provider(ethereum);\r\n        const signer = provider.getSigner();\r\n        const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\r\n\r\n        let count = await wavePortalContract.getTotalWaves();\r\n        console.log(\"Retrieved total wave count...\", count.toNumber());\r\n\r\n        /*\r\n        * Execute the actual wave from your smart contract\r\n        */\r\n        const waveTxn = await wavePortalContract.wave(message);\r\n        console.log(\"Mining...\", waveTxn.hash);\r\n\r\n        await waveTxn.wait();\r\n        console.log(\"Mined -- \", waveTxn.hash);\r\n\r\n        count = await wavePortalContract.getTotalWaves();\r\n        console.log(\"Retrieved total wave count...\", count.toNumber());\r\n      } else {\r\n        console.log(\"Ethereum object doesn't exist!\");\r\n      }\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n\r\n  const handleChange = e => {\r\n    setMessage(e.target.value)\r\n  }\r\n\r\n\r\n\r\n  useEffect(() => {\r\n    checkIfWalletIsConnected();\r\n  }, [])\r\n\r\n  return (\r\n    <div className=\"mainContainer\">\r\n      <div className=\"dataContainer\">\r\n        <div className=\"header\">\r\n          GM #Web3 ðŸ¦„\r\n        </div>\r\n\r\n        <div className=\"bio\">\r\n          I am 0xCharl.eth and I have been developing Web3 and blockchain for 5+ years! Connect your Ethereum wallet to Rinkeby and send me a message!\r\n\r\n        </div>\r\n    \r\n\r\n        <textarea\r\n          name=\"message\"\r\n          value={message}\r\n          onChange={handleChange}\r\n        />\r\n\r\n\r\n        <button className=\"waveButton\" onClick={wave}>\r\n          Send Message ðŸŒž\r\n        </button>\r\n       \r\n\r\n        {!currentAccount && (\r\n          <button className=\"waveButton\" onClick={connectWallet}>\r\n            Connect Wallet\r\n          </button>\r\n        )}\r\n\r\n        {allWaves.map((wave, index) => {\r\n          return (\r\n            <div key={index} style={{ backgroundColor: \"Beige\", marginTop: \"16px\", padding: \"8px\" }}>\r\n              <div>Address: {wave.address}</div>\r\n              <div>Time: {wave.timestamp.toString()}</div>\r\n              <div>Message: {wave.message}</div>\r\n            </div>)\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}